<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate implements the virtual memory subsystem for Theseus, which is fairly robust and provides a unification between  arbitrarily mapped sections of memory and Rust’s lifetime system.  Originally based on Phil Opp’s blog_os. "><meta name="keywords" content="rust, rustlang, rust-lang, memory"><title>memory - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../memory/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate memory</p><div class="block version"><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all memory's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#statics">Statics</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="memory" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">memory</a><button id="copy-path" onclick="copy_path(this)"><img src="../clipboard.svg" width="19" height="18" alt="Copy item import"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/memory/lib.rs.html#1-271" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate implements the virtual memory subsystem for Theseus,
which is fairly robust and provides a unification between 
arbitrarily mapped sections of memory and Rust’s lifetime system. 
Originally based on Phil Opp’s blog_os. </p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.AggregatedSectionMemoryBounds.html" title="memory::AggregatedSectionMemoryBounds struct">AggregatedSectionMemoryBounds</a></td><td class="docblock-short"><p>The address bounds and flags of the initial kernel sections that need mapping. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.AllocatedFrames.html" title="memory::AllocatedFrames struct">AllocatedFrames</a></td><td class="docblock-short"><p>Represents a range of allocated <code>PhysicalAddress</code>es, specified in <code>Frame</code>s. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.AllocatedPages.html" title="memory::AllocatedPages struct">AllocatedPages</a></td><td class="docblock-short"><p>Represents a range of allocated <code>VirtualAddress</code>es, specified in <code>Page</code>s. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DeferredAllocAction.html" title="memory::DeferredAllocAction struct">DeferredAllocAction</a></td><td class="docblock-short"><p>A series of pending actions related to page allocator bookkeeping,
which may result in heap allocation. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DeferredAllocAction.html" title="memory::DeferredAllocAction struct">DeferredAllocAction</a></td><td class="docblock-short"><p>A series of pending actions related to frame allocator bookkeeping,
which may result in heap allocation. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.EntryFlags.html" title="memory::EntryFlags struct">EntryFlags</a></td><td class="docblock-short"><p>Page table entry flags on the x86_64 architecture. </p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Frame.html" title="memory::Frame struct">Frame</a></td><td class="docblock-short"><p>A <code>Frame</code> is a chunk of <strong>physical</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.FrameRange.html" title="memory::FrameRange struct">FrameRange</a></td><td class="docblock-short"><p>A range of <a href="struct.Frame.html" title="Frame"><code>Frame</code></a>s that are contiguous in physical memory.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.MappedPages.html" title="memory::MappedPages struct">MappedPages</a></td><td class="docblock-short"><p>Represents a contiguous range of virtual memory pages that are currently mapped. 
A <code>MappedPages</code> object can only have a single range of contiguous pages, not multiple disjoint ranges.
This does not guarantee that its pages are mapped to frames that are contiguous in physical memory.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Mapper.html" title="memory::Mapper struct">Mapper</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.MemoryManagementInfo.html" title="memory::MemoryManagementInfo struct">MemoryManagementInfo</a></td><td class="docblock-short"><p>This holds all the information for a <code>Task</code>’s memory mappings and address space
(this is basically the equivalent of Linux’s mm_struct)</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Page.html" title="memory::Page struct">Page</a></td><td class="docblock-short"><p>A <code>Page</code> is a chunk of <strong>virtual</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PageRange.html" title="memory::PageRange struct">PageRange</a></td><td class="docblock-short"><p>A range of <a href="struct.Page.html" title="Page"><code>Page</code></a>s that are contiguous in virtual memory.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PageTable.html" title="memory::PageTable struct">PageTable</a></td><td class="docblock-short"><p>A top-level root (P4) page table.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PageTableEntry.html" title="memory::PageTableEntry struct">PageTableEntry</a></td><td class="docblock-short"><p>A page table entry, which is a <code>u64</code> value under the hood.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PhysicalAddress.html" title="memory::PhysicalAddress struct">PhysicalAddress</a></td><td class="docblock-short"><p>A physical memory address, which is a <code>usize</code> under the hood.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PhysicalMemoryRegion.html" title="memory::PhysicalMemoryRegion struct">PhysicalMemoryRegion</a></td><td class="docblock-short"><p>A region of physical memory.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SectionMemoryBounds.html" title="memory::SectionMemoryBounds struct">SectionMemoryBounds</a></td><td class="docblock-short"><p>The address bounds and mapping flags of a section’s memory region.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.TemporaryPage.html" title="memory::TemporaryPage struct">TemporaryPage</a></td><td class="docblock-short"><p>A page that can be temporarily mapped to the recursive page table frame,
used for purposes of editing a top-level (P4) page table itself.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.UnmappedFrames.html" title="memory::UnmappedFrames struct">UnmappedFrames</a></td><td class="docblock-short"><p>A range of frames that have been unmapped from a <code>PageTableEntry</code>
that previously mapped that frame exclusively (i.e., “owned it”).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.VirtualAddress.html" title="memory::VirtualAddress struct">VirtualAddress</a></td><td class="docblock-short"><p>A virtual memory address, which is a <code>usize</code> under the hood.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.MemoryRegionType.html" title="memory::MemoryRegionType enum">MemoryRegionType</a></td><td class="docblock-short"><p>Types of physical memory. See each variant’s documentation.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.UnmapResult.html" title="memory::UnmapResult enum">UnmapResult</a></td><td class="docblock-short"><p>The frames returned from the action of unmapping a page table entry.
See the <code>PageTableEntry::set_unmapped()</code> function.</p>
</td></tr></table><h2 id="constants" class="section-header"><a href="#constants">Constants</a></h2>
<table><tr class="module-item"><td><a class="constant" href="constant.PAGE_SIZE.html" title="memory::PAGE_SIZE constant">PAGE_SIZE</a></td><td class="docblock-short"><p>Page size is 4096 bytes, 4KiB pages.</p>
</td></tr></table><h2 id="statics" class="section-header"><a href="#statics">Statics</a></h2>
<table><tr class="module-item"><td><a class="static" href="static.BROADCAST_TLB_SHOOTDOWN_FUNC.html" title="memory::BROADCAST_TLB_SHOOTDOWN_FUNC static">BROADCAST_TLB_SHOOTDOWN_FUNC</a></td><td class="docblock-short"></td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.allocate_frames.html" title="memory::allocate_frames fn">allocate_frames</a></td><td class="docblock-short"><p>Allocates the given number of frames with no constraints on the starting physical address.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_frames_at.html" title="memory::allocate_frames_at fn">allocate_frames_at</a></td><td class="docblock-short"><p>Allocates the given number of frames starting at (inclusive of) the frame containing the given <code>PhysicalAddress</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_frames_by_bytes.html" title="memory::allocate_frames_by_bytes fn">allocate_frames_by_bytes</a></td><td class="docblock-short"><p>Allocates frames with no constraints on the starting physical address, 
with a size given by the number of bytes. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_frames_by_bytes_at.html" title="memory::allocate_frames_by_bytes_at fn">allocate_frames_by_bytes_at</a></td><td class="docblock-short"><p>Allocates frames starting at the given <code>PhysicalAddress</code> with a size given in number of bytes. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_frames_by_bytes_deferred.html" title="memory::allocate_frames_by_bytes_deferred fn">allocate_frames_by_bytes_deferred</a></td><td class="docblock-short"><p>Similar to <a href="fn.allocate_frames_deferred.html"><code>allocated_frames_deferred()</code></a>,
but accepts a size value for the allocated frames in number of bytes instead of number of frames. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_frames_deferred.html" title="memory::allocate_frames_deferred fn">allocate_frames_deferred</a></td><td class="docblock-short"><p>The core frame allocation routine that allocates the given number of physical frames,
optionally at the requested starting <code>PhysicalAddress</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages.html" title="memory::allocate_pages fn">allocate_pages</a></td><td class="docblock-short"><p>Allocates the given number of pages with no constraints on the starting virtual address.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages_at.html" title="memory::allocate_pages_at fn">allocate_pages_at</a></td><td class="docblock-short"><p>Allocates the given number of pages starting at (inclusive of) the page containing the given <code>VirtualAddress</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages_by_bytes.html" title="memory::allocate_pages_by_bytes fn">allocate_pages_by_bytes</a></td><td class="docblock-short"><p>Allocates pages with no constraints on the starting virtual address, 
with a size given by the number of bytes. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages_by_bytes_at.html" title="memory::allocate_pages_by_bytes_at fn">allocate_pages_by_bytes_at</a></td><td class="docblock-short"><p>Allocates pages starting at the given <code>VirtualAddress</code> with a size given in number of bytes. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages_by_bytes_deferred.html" title="memory::allocate_pages_by_bytes_deferred fn">allocate_pages_by_bytes_deferred</a></td><td class="docblock-short"><p>Similar to <a href="fn.allocate_pages_deferred.html"><code>allocated_pages_deferred()</code></a>,
but accepts a size value for the allocated pages in number of bytes instead of number of pages. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.allocate_pages_deferred.html" title="memory::allocate_pages_deferred fn">allocate_pages_deferred</a></td><td class="docblock-short"><p>The core page allocation routine that allocates the given number of virtual pages,
optionally at the requested starting <code>VirtualAddress</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.create_contiguous_mapping.html" title="memory::create_contiguous_mapping fn">create_contiguous_mapping</a></td><td class="docblock-short"><p>A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory.
If contiguous frames are not required, then see <a href="fn.create_mapping.html"><code>create_mapping()</code></a>.
Returns a tuple containing the new <code>MappedPages</code> and the starting PhysicalAddress of the first frame,
which is a convenient way to get the physical address without walking the page tables.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.create_mapping.html" title="memory::create_mapping fn">create_mapping</a></td><td class="docblock-short"><p>A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there’s
no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required
then see <a href="fn.create_contiguous_mapping.html"><code>create_contiguous_mapping()</code></a>.
Returns the new <code>MappedPages.</code> </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.get_current_p4.html" title="memory::get_current_p4 fn">get_current_p4</a></td><td class="docblock-short"><p>Returns the current top-level (P4) root page table frame.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.get_kernel_mmi_ref.html" title="memory::get_kernel_mmi_ref fn">get_kernel_mmi_ref</a></td><td class="docblock-short"><p>Returns a cloned reference to the kernel’s <code>MemoryManagementInfo</code>, if initialized.
If not, it returns None.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.init.html" title="memory::init fn">init</a></td><td class="docblock-short"><p>Initialize the page allocator.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.init.html" title="memory::init fn">init</a></td><td class="docblock-short"><p>Initialize the frame allocator with the given list of available and reserved physical memory regions.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.init.html" title="memory::init fn">init</a></td><td class="docblock-short"><p>Initializes the virtual memory management system.
Consumes the given BootInformation, because after the memory system is initialized,
the original BootInformation will be unmapped and inaccessible.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.init_post_heap.html" title="memory::init_post_heap fn">init_post_heap</a></td><td class="docblock-short"><p>Finishes initializing the virtual memory management system after the heap is initialized and returns a MemoryManagementInfo instance,
which represents the initial (the kernel’s) address space. </p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.set_broadcast_tlb_shootdown_cb.html" title="memory::set_broadcast_tlb_shootdown_cb fn">set_broadcast_tlb_shootdown_cb</a></td><td class="docblock-short"><p>Set the function callback that will be invoked every time a TLB shootdown is necessary,
i.e., during page table remapping and unmapping operations.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.MmiRef.html" title="memory::MmiRef type">MmiRef</a></td><td class="docblock-short"><p>A shareable reference to a <code>MemoryManagementInfo</code> struct wrapper in a lock.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="memory" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>