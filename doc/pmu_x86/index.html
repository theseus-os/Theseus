<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Support for the Performance Monitoring Unit "><meta name="keywords" content="rust, rustlang, rust-lang, pmu_x86"><title>pmu_x86 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fbcde169c4acde5f.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-bc1b32400f872ddb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../pmu_x86/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../pmu_x86/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate pmu_x86</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">pmu_x86</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/pmu_x86/lib.rs.html#1-916">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Support for the Performance Monitoring Unit </p>
<p>We have support for PMU version 2. Each succesive PMU version includes the features provided by the previous versions.</p>
<p>Version 1 Support:
To configure an architectural performance monitoring event, we program the performance event select registers (IA32_PERFEVTSELx MSRs).
The result of the performance monitoring event is reported in a general purpose Performance Monitoring Counter (PMC) (IA32_PMCx MSR).
There is one PMC for each performance event select register, and one PMU per logical core. </p>
<p>Version 2 Support:
Three of the architectural events are counted using fixed function MSRs (IA32_FIXED_CTR0 through IA32_FIXED_CTR2), 
each with an associated control register.
Three more MSRS are provided to simplify event programming. They are: </p>
<ul>
<li>IA32_PERF_GLOBAL_CTRL: 
allows software to enable/disable event counting of any combination of fixed-function PMCs or any general-purpose PMCs via a single WRMSR.</li>
<li>IA32_PERF_GLOBAL_STATUS: 
allows software to query counter overflow conditions on any combination of fixed-function PMCs or general-purpose PMCs via a single RDMSR.</li>
<li>IA32_PERF_GLOBAL_OVF_CTRL: 
allows software to clear counter overflow conditions on any combination of fixed-function PMCs or general-purpose PMCs via a single WRMSR.</li>
</ul>
<p>We support 2 ways to use the PMU. One is to measure the number of events that take place over a length of code.
The second is Event Based Sampling, where after a specified number of events occur, an interrupt is called and we store the instruction pointer 
and task id running at that point.</p>
<p>Currently we support a maximum core ID of 255, and up to 8 general purpose counters per core. 
A core ID greater than 255 is not supported in Theseus in general since the ID has to fit within a u8.</p>
<p>If the core ID limit is changed and we need to update the PMU data structures to support more cores then: </p>
<ul>
<li>Increase WORDS_IN_BITMAP and CORES_SUPPORTED_BY_PMU as required. For example, the cores supported is 256 so there are 4 64-bit words in the bitmap, one bit per core. </li>
<li>Add additional AtomicU64 variables to the initialization of the CORES_SAMPLING and RESULTS_READY bitmaps. </li>
</ul>
<p>If the general purpose PMC limit is reached then: </p>
<ul>
<li>Update PMCS_SUPPORTED_BY_PMU to the new PMC limit.</li>
<li>Change the element type in the PMCS_AVAILABLE vector to be larger than AtomicU8 so that there is one bit per counter.</li>
<li>Update INIT_PMCS_AVAILABLE to the new maximum value for the per core bitmap.</li>
</ul>
<p>Monitoring without interrupts is almost free (around 0.3% performance penalty) - source: “These are Not Your Grand Daddy’s CPU Performance Counters” Blackhat USA, 2015</p>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>pmu_x86::init();
 
<span class="kw">let </span>counter_freq = <span class="number">0xFFFFF</span>;
<span class="kw">let </span>num_samples = <span class="number">500</span>;
<span class="kw">let </span>sampler = pmu_x86::start_samples(pmu_x86::EventType::UnhaltedReferenceCycles, counter_freq, <span class="prelude-val">None</span>, num_samples);
 
<span class="kw">if let </span><span class="prelude-val">Ok</span>(my_sampler) = sampler {
 
    <span class="comment">// wait some time here
     
    </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(<span class="kw-2">mut </span>samples) = pmu_x86::retrieve_samples() {
        pmu_x86::print_samples(<span class="kw-2">&amp;mut </span>samples);
    }
}</code></pre></div>
<h2 id="note"><a href="#note">Note</a></h2>
<p>Currently, the PMU-based sampler will only capture samples on the same core as it was initialized and started from. 
So, if you run <code>pmu_x86::init()</code> and <code>pmu_x86::start_samples()</code> on CPU core 2, it will only sample events on core 2.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="stat/index.html" title="pmu_x86::stat mod">stat</a></div><div class="item-right docblock-short">This module implements the equivalent of “perf stat”.
Currently only 7 events are recorded.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Counter.html" title="pmu_x86::Counter struct">Counter</a></div><div class="item-right docblock-short">A logical counter object to correspond to a physical PMC</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SampleResults.html" title="pmu_x86::SampleResults struct">SampleResults</a></div><div class="item-right docblock-short">Stores the instruction pointers and corresponding task IDs from the samples</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.EventType.html" title="pmu_x86::EventType enum">EventType</a></div><div class="item-right docblock-short">Used to select the event type to count. Event types are described in the Intel SDM 18.2.1 for PMU Version 1.
The discriminant value for each event type is the value written to the event select register for a general purpose PMC.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.find_function_names_from_samples.html" title="pmu_x86::find_function_names_from_samples fn">find_function_names_from_samples</a></div><div class="item-right docblock-short">Finds the corresponding function for each instruction pointer and calculates the percentage amount each function occured in the samples</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.handle_sample.html" title="pmu_x86::handle_sample fn">handle_sample</a></div><div class="item-right docblock-short">This function is designed to be invoked from an interrupt handler 
when a sampling interrupt has (or may have) occurred. </div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.init.html" title="pmu_x86::init fn">init</a></div><div class="item-right docblock-short">Initialization function that enables the PMU if one is available.
We initialize the 3 fixed PMCs and general purpose PMCs. Calling this initialization function again
on a core that has already been initialized will do nothing.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.print_samples.html" title="pmu_x86::print_samples fn">print_samples</a></div><div class="item-right docblock-short">Simple function to print values from SampleResults in a form that the script “post-mortem pmu analysis.py” can parse. </div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.reset_pmu.html" title="pmu_x86::reset_pmu fn">reset_pmu</a></div><div class="item-right docblock-short">Frees all counters and make them available to be used.
Essentially sets the PMU to its initial state.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.retrieve_samples.html" title="pmu_x86::retrieve_samples fn">retrieve_samples</a></div><div class="item-right docblock-short">Returns the samples that were stored during sampling in the form of a SampleResults object. 
If samples are not yet finished, forces them to stop.  </div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.start_samples.html" title="pmu_x86::start_samples fn">start_samples</a></div><div class="item-right docblock-short">Start interrupt process in order to take samples using the PMU. 
It loads the starting value as such that an overflow will occur at “event_per_sample” events. 
That overflow triggers an interrupt where information about the current running task is sampled.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="pmu_x86" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (0442fbabe 2023-01-10)" data-search-js="search-181581080540673f.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-58836c674e2f7bd2.css" ></div></body></html>