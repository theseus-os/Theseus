<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Support for unwinding the call stack and cleaning up stack frames."><title>unwind - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="unwind" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (065a1f5df 2023-06-21)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../unwind/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../unwind/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate unwind</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li><li><a href="#trait-aliases">Trait Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">unwind</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/unwind/lib.rs.html#1-925">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Support for unwinding the call stack and cleaning up stack frames.</p>
<p>Uses DWARF debugging information (<code>.eh_frame</code> and <code>.gcc_except_table</code> sections) from object files.
It can also be used to generate stack traces (backtrace) using only that debug information
without using frame pointer registers.</p>
<p>The general flow of the unwinding procedure is as follows:</p>
<ul>
<li>A panic occurs, which jumps to the panic entry point. </li>
<li>The panic entry point invokes the panic_wrapper, which handles said panic 
by invoking <code>start_unwinding()</code> in this crate with the reason for the panic.</li>
<li><code>start_unwinding()</code> generates an iterator over all stack frames in the call stack
(the knowledge for which comes from parsing the .eh_frame section).</li>
<li><code>start_unwinding()</code> creates an unwinding context, which contains the stack frame iterator, 
the reason for the panic, and a reference to the current task being unwound.
It then skips the first several stack frames, which correspond to the panic and unwind handlers themselves.
Note that we cannot unwind those frames because they contain resources that we are currently using for unwinding purposes.</li>
<li>At any point hereafter, the unwinding context must be manually cleaned up.</li>
<li><code>start_unwinding()</code> calls <code>continue_unwinding()</code>, which contains the bulk of the unwinding logic.</li>
<li><code>continue_unwinding()</code> iterates to the “next” stack frame (the previous frame in the call stack),
and invokes its cleanup routine (landing pad) if it has one. </li>
<li>Once the cleanup routine is complete, it jumps to <code>_Unwind_Resume</code> automatically. 
This cannot be changed and is an artifact of how unwinding routines are generated by the compiler.</li>
<li><code>_Unwind_Resume</code> is defined alongside the panic entry pointer, and is nothing more
than a simple wrapper that invokes <code>continue_unwinding()</code> here. </li>
<li><code>continue_unwinding()</code> continues iterating up the call stack. 
Once it reaches the end of the call stack (or an error occurs),
we invoke a finalizer routine called <code>cleanup_unwinding_context()</code>. </li>
<li>In <code>cleanup_unwinding_context()</code>, the unwinding context pointer is recovered and all unwinding resources are freed.
Finally, the task is marked as killed so it can no longer be scheduled in. </li>
</ul>
<p>The flow of some functions was inspired by gcc’s <code>libunwind</code>
and from <code>gimli/unwind-rs/src/glue.rs</code>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.StackFrame.html" title="struct unwind::StackFrame">StackFrame</a></div><div class="desc docblock-short">A single frame in the stack, which contains
unwinding-related information for a single function call’s stack frame.</div></li><li><div class="item-name"><a class="struct" href="struct.StackFrameIter.html" title="struct unwind::StackFrameIter">StackFrameIter</a></div><div class="desc docblock-short">An iterator over the stack frames on the current task’s call stack,
which works in reverse calling order from the current function
up the call stack to the very first function on the stack,
at which point it will return <code>None</code>. </div></li><li><div class="item-name"><a class="struct" href="struct.UnwindingContext.html" title="struct unwind::UnwindingContext">UnwindingContext</a></div><div class="desc docblock-short">This is the context/state that is used during unwinding and passed around
to the callback functions in the various unwinding stages, such as in <code>_Unwind_Resume()</code>. </div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.invoke_with_current_registers.html" title="fn unwind::invoke_with_current_registers">invoke_with_current_registers</a></div><div class="desc docblock-short">This function saves the current CPU register values onto the stack (to preserve them)
and then invokes the given closure with those registers as the argument.</div></li></ul><h2 id="trait-aliases" class="small-section-header"><a href="#trait-aliases">Trait Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="traitalias" href="traitalias.FuncWithRegisters.html" title="traitalias unwind::FuncWithRegisters">FuncWithRegisters</a></div></li></ul></section></div></main></body></html>