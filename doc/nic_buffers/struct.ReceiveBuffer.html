<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A buffer that stores a packet (a piece of an Ethernet frame) that has been received from the NIC and is guaranteed to be contiguous in physical memory.  Auto-dereferences into a `MappedPages` object that represents its underlying memory.  When dropped, its underlying memory is automatically returned to the NIC driver for future reuse."><meta name="keywords" content="rust, rustlang, rust-lang, ReceiveBuffer"><title>ReceiveBuffer in nic_buffers - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../nic_buffers/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Struct ReceiveBuffer</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#fields">Fields</a><div class="sidebar-links"><a href="#structfield.length">length</a><a href="#structfield.mp">mp</a><a href="#structfield.phys_addr">phys_addr</a></div><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.new">new</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Deref">Deref</a><a href="#impl-DerefMut">DerefMut</a><a href="#impl-Drop">Drop</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-Erased">Erased</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div><a class="sidebar-title" href="#deref-methods-MappedPages">Methods from Deref&lt;Target=MappedPages&gt;</a><div class="sidebar-links"><a href="#method.as_slice">as_slice</a><a href="#method.as_slice_mut">as_slice_mut</a><a href="#method.as_type">as_type</a><a href="#method.as_type_mut">as_type_mut</a><a href="#method.flags">flags</a><a href="#method.merge">merge</a><a href="#method.remap">remap</a></div><a class="sidebar-title" href="#deref-methods-PageRange">Methods from Deref&lt;Target=PageRange&gt;</a><div class="sidebar-links"><a href="#method.address_at_offset">address_at_offset</a><a href="#method.contains_address">contains_address</a><a href="#method.offset_of_address">offset_of_address</a><a href="#method.overlap">overlap</a><a href="#method.size_in_bytes">size_in_bytes</a><a href="#method.size_in_pages">size_in_pages</a><a href="#method.start_address">start_address</a><a href="#method.to_extended">to_extended</a></div><a class="sidebar-title" href="#deref-methods-RangeInclusive%3CPage%3E">Methods from Deref&lt;Target=RangeInclusive&lt;Page&gt;&gt;</a><div class="sidebar-links"><a href="#method.contains">contains</a><a href="#method.end">end</a><a href="#method.is_empty">is_empty</a><a href="#method.start">start</a></div></div><p class="location"><a href="index.html">nic_buffers</a></p><div id="sidebar-vars" data-name="ReceiveBuffer" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="index.html">nic_buffers</a>::<wbr><a class="struct" href="">ReceiveBuffer</a><button id="copy-path" onclick="copy_path(this)"><img src="../clipboard.svg" width="19" height="18" alt="Copy item import"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/nic_buffers/lib.rs.html#62-67" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust struct">pub struct ReceiveBuffer {
    pub mp: <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a>,
    pub phys_addr: <a class="struct" href="../memory_structs/struct.PhysicalAddress.html" title="struct memory_structs::PhysicalAddress">PhysicalAddress</a>,
    pub length: u16,
    // some fields omitted
}</pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A buffer that stores a packet (a piece of an Ethernet frame) that has been received from the NIC
and is guaranteed to be contiguous in physical memory. 
Auto-dereferences into a <code>MappedPages</code> object that represents its underlying memory. 
When dropped, its underlying memory is automatically returned to the NIC driver for future reuse.</p>
</div></details><h2 id="fields" class="fields small-section-header">
                       Fields<a href="#fields" class="anchor"></a></h2><span id="structfield.mp" class="structfield small-section-header"><a href="#structfield.mp" class="anchor field"></a><code>mp: <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a></code></span><span id="structfield.phys_addr" class="structfield small-section-header"><a href="#structfield.phys_addr" class="anchor field"></a><code>phys_addr: <a class="struct" href="../memory_structs/struct.PhysicalAddress.html" title="struct memory_structs::PhysicalAddress">PhysicalAddress</a></code></span><span id="structfield.length" class="structfield small-section-header"><a href="#structfield.length" class="anchor field"></a><code>length: u16</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl" class="impl"><code class="in-band">impl <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#68-79" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;mp: <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;phys_addr: <a class="struct" href="../memory_structs/struct.PhysicalAddress.html" title="struct memory_structs::PhysicalAddress">PhysicalAddress</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;length: u16, <br>&nbsp;&nbsp;&nbsp;&nbsp;pool: &amp;'static Queue&lt;<a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a>&gt;<br>) -&gt; <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#method.new" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#71-78" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Creates a new ReceiveBuffer with the given <code>MappedPages</code>, <code>PhysicalAddress</code>, and <code>length</code>. 
When this ReceiveBuffer object is dropped, it will be returned to the given <code>pool</code>.</p>
</div></details></div></details><h2 id="deref-methods-MappedPages" class="small-section-header">Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a>&gt;<a href="#deref-methods-MappedPages" class="anchor"></a></h2><div class="impl-items"><details class="rustdoc-toggle" open><summary><h4 id="method.flags" class="method"><code>pub fn <a href="#method.flags" class="fnname">flags</a>(&amp;self) -&gt; <a class="struct" href="../entryflags_x86_64/struct.EntryFlags.html" title="struct entryflags_x86_64::EntryFlags">EntryFlags</a></code><a href="#method.flags" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#326" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the flags that describe this <code>MappedPages</code> page table permissions.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.merge" class="method"><code>pub fn <a href="#method.merge" class="fnname">merge</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mp: <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(), (&amp;'static str, <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a>)&gt;</code><a href="#method.merge" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#346" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Merges the given <code>MappedPages</code> object <code>mp</code> into this <code>MappedPages</code> object (<code>self</code>).</p>
<p>For example, if you have the following <code>MappedPages</code> objects:</p>
<ul>
<li>this mapping, with a page range including one page at 0x2000</li>
<li><code>mp</code>, with a page range including two pages at 0x3000 and 0x4000
Then this <code>MappedPages</code> object will be updated to cover three pages from <code>[0x2000:0x4000]</code> inclusive.</li>
</ul>
<p>In addition, the <code>MappedPages</code> objects must have the same flags and page table root frame
(i.e., they must have all been mapped using the same set of page tables).</p>
<p>If an error occurs, such as the <code>mappings</code> not being contiguous or having different flags, 
then a tuple including an error message and the original <code>mp</code> will be returned,
which prevents the <code>mp</code> from being dropped. </p>
<h1 id="note" class="section-header"><a href="#note">Note</a></h1>
<p>No remapping actions or page reallocations will occur on either a failure or a success.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.remap" class="method"><code>pub fn <a href="#method.remap" class="fnname">remap</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;active_table_mapper: &amp;mut <a class="struct" href="../memory/paging/mapper/struct.Mapper.html" title="struct memory::paging::mapper::Mapper">Mapper</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;new_flags: <a class="struct" href="../entryflags_x86_64/struct.EntryFlags.html" title="struct entryflags_x86_64::EntryFlags">EntryFlags</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(), &amp;'static str&gt;</code><a href="#method.remap" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#423" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Change the permissions (<code>new_flags</code>) of this <code>MappedPages</code>’s page table entries.</p>
<p>Note that attempting to change certain “reserved” flags will have no effect. 
For example, arbitrarily setting the <code>EXCLUSIVE</code> bit would cause unsafety, so it cannot be changed.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.as_type" class="method"><code>pub fn <a href="#method.as_type" class="fnname">as_type</a>&lt;T&gt;(&amp;self, offset: usize) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;T, &amp;'static str&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: FromBytes,&nbsp;</span></code><a href="#method.as_type" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#604" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Reinterprets this <code>MappedPages</code>’s underlying memory region as a struct of the given type <code>T</code>,
i.e., overlays a struct on top of this mapped memory region. </p>
<h1 id="requirements" class="section-header"><a href="#requirements">Requirements</a></h1>
<p>The type <code>T</code> must implement the <code>FromBytes</code> trait, which is similar to the requirements 
of a “plain old data” type, in that it cannot contain Rust references (<code>&amp;</code> or <code>&amp;mut</code>).
This makes sense because there is no valid way to reinterpret a region of untyped memory 
as a Rust reference. 
In addition, if we did permit that, a Rust reference created from unchecked memory contents
could never be valid, safe, or sound, as it could allow random memory access 
(just like with an arbitrary pointer dereference) that could break isolation.</p>
<p>To satisfy this condition, you can use <code>#[derive(FromBytes)]</code> on your struct type <code>T</code>,
which will only compile correctly if the struct can be validly constructed 
from “untyped” memory, i.e., an array of bytes.</p>
<h1 id="arguments" class="section-header"><a href="#arguments">Arguments</a></h1>
<p><code>offset</code>: the offset into the memory region at which the struct is located (where it should start).</p>
<p>Returns a reference to the new struct (<code>&amp;T</code>) that is formed from the underlying memory region,
with a lifetime dependent upon the lifetime of this <code>MappedPages</code> object.
This ensures safety by guaranteeing that the returned struct reference 
cannot be used after this <code>MappedPages</code> object is dropped and unmapped.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.as_type_mut" class="method"><code>pub fn <a href="#method.as_type_mut" class="fnname">as_type_mut</a>&lt;T&gt;(&amp;mut self, offset: usize) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut T, &amp;'static str&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: FromBytes,&nbsp;</span></code><a href="#method.as_type_mut" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#635" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Same as <a href="#method.as_type"><code>as_type()</code></a>, but returns a <em>mutable</em> reference to the type <code>T</code>.</p>
<p>Thus, it checks to make sure that the underlying mapping is writable.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.as_slice" class="method"><code>pub fn <a href="#method.as_slice" class="fnname">as_slice</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;byte_offset: usize, <br>&nbsp;&nbsp;&nbsp;&nbsp;length: usize<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;[T], &amp;'static str&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: FromBytes,&nbsp;</span></code><a href="#method.as_slice" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#685" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Reinterprets this <code>MappedPages</code>’s underlying memory region as a slice of any type.</p>
<p>It has similar type requirements as the <a href="#method.as_type"><code>as_type()</code></a> method.</p>
<h1 id="arguments-1" class="section-header"><a href="#arguments-1">Arguments</a></h1>
<ul>
<li><code>byte_offset</code>: the offset (in number of bytes) into the memory region at which the slice should start.</li>
<li><code>length</code>: the length of the slice, i.e., the number of <code>T</code> elements in the slice. 
Thus, the slice will go from <code>offset</code> to <code>offset</code> + (sizeof(<code>T</code>) * <code>length</code>).</li>
</ul>
<p>Returns a reference to the new slice that is formed from the underlying memory region,
with a lifetime dependent upon the lifetime of this <code>MappedPages</code> object.
This ensures safety by guaranteeing that the returned slice 
cannot be used after this <code>MappedPages</code> object is dropped and unmapped.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.as_slice_mut" class="method"><code>pub fn <a href="#method.as_slice_mut" class="fnname">as_slice_mut</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;byte_offset: usize, <br>&nbsp;&nbsp;&nbsp;&nbsp;length: usize<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut [T], &amp;'static str&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: FromBytes,&nbsp;</span></code><a href="#method.as_slice_mut" class="anchor"></a><a class="srclink" href="../src/memory/paging/mapper.rs.html#716" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Same as <a href="#method.as_slice"><code>as_slice()</code></a>, but returns a <em>mutable</em> slice. </p>
<p>Thus, it checks to make sure that the underlying mapping is writable.</p>
</div></details></div><h2 id="deref-methods-PageRange" class="small-section-header">Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../memory_structs/struct.PageRange.html" title="struct memory_structs::PageRange">PageRange</a>&gt;<a href="#deref-methods-PageRange" class="anchor"></a></h2><div class="impl-items"><details class="rustdoc-toggle" open><summary><h4 id="method.start_address" class="method"><code>pub const fn <a href="#method.start_address" class="fnname">start_address</a>(&amp;self) -&gt; <a class="struct" href="../memory_structs/struct.VirtualAddress.html" title="struct memory_structs::VirtualAddress">VirtualAddress</a></code><a href="#method.start_address" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the <a href="../memory_structs/struct.VirtualAddress.html" title="VirtualAddress"><code>VirtualAddress</code></a> of the starting <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a> in this <code>PageRange</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.size_in_pages" class="method"><code>pub const fn <a href="#method.size_in_pages" class="fnname">size_in_pages</a>(&amp;self) -&gt; usize</code><a href="#method.size_in_pages" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the number of <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a>s covered by this iterator.</p>
<p>Use this instead of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#method.count" title="Iterator::count()"><code>Iterator::count()</code></a> method. This is instant, because it doesn’t need to iterate over each entry, unlike normal iterators.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.size_in_bytes" class="method"><code>pub const fn <a href="#method.size_in_bytes" class="fnname">size_in_bytes</a>(&amp;self) -&gt; usize</code><a href="#method.size_in_bytes" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the size of this range in number of bytes.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.contains_address" class="method"><code>pub fn <a href="#method.contains_address" class="fnname">contains_address</a>(&amp;self, addr: <a class="struct" href="../memory_structs/struct.VirtualAddress.html" title="struct memory_structs::VirtualAddress">VirtualAddress</a>) -&gt; bool</code><a href="#method.contains_address" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns <code>true</code> if this <code>PageRange</code> contains the given <a href="../memory_structs/struct.VirtualAddress.html" title="VirtualAddress"><code>VirtualAddress</code></a>.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.offset_of_address" class="method"><code>pub fn <a href="#method.offset_of_address" class="fnname">offset_of_address</a>(&amp;self, addr: <a class="struct" href="../memory_structs/struct.VirtualAddress.html" title="struct memory_structs::VirtualAddress">VirtualAddress</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;usize&gt;</code><a href="#method.offset_of_address" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the offset of the given <a href="../memory_structs/struct.VirtualAddress.html" title="VirtualAddress"><code>VirtualAddress</code></a> within this <code>PageRange</code>, i.e., <code>addr - self.start_address()</code>.</p>
<p>If the given <code>addr</code> is not covered by this range of <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a>s, this returns <code>None</code>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>If the range covers addresses <code>0x2000</code> to <code>0x4000</code>, then <code>offset_of_address(0x3500)</code> would return <code>Some(0x1500)</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.address_at_offset" class="method"><code>pub fn <a href="#method.address_at_offset" class="fnname">address_at_offset</a>(&amp;self, offset: usize) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../memory_structs/struct.VirtualAddress.html" title="struct memory_structs::VirtualAddress">VirtualAddress</a>&gt;</code><a href="#method.address_at_offset" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the <a href="../memory_structs/struct.VirtualAddress.html" title="VirtualAddress"><code>VirtualAddress</code></a> at the given <code>offset</code> into this <code>PageRange</code>within this <code>PageRange</code>, i.e., <code>addr - self.start_address()</code>.</p>
<p>If the given <code>offset</code> is not within this range of <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a>s, this returns <code>None</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>If the range covers addresses <code>0x2000</code> to <code>0x4000</code>, then <code>address_at_offset(0x1500)</code> would return <code>Some(0x3500)</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.to_extended" class="method"><code>pub fn <a href="#method.to_extended" class="fnname">to_extended</a>(&amp;self, to_include: <a class="struct" href="../memory_structs/struct.Page.html" title="struct memory_structs::Page">Page</a>) -&gt; <a class="struct" href="../memory_structs/struct.PageRange.html" title="struct memory_structs::PageRange">PageRange</a></code><a href="#method.to_extended" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns a new separate <code>PageRange</code> that is extended to include the given <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a>.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.overlap" class="method"><code>pub fn <a href="#method.overlap" class="fnname">overlap</a>(&amp;self, other: &amp;<a class="struct" href="../memory_structs/struct.PageRange.html" title="struct memory_structs::PageRange">PageRange</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../memory_structs/struct.PageRange.html" title="struct memory_structs::PageRange">PageRange</a>&gt;</code><a href="#method.overlap" class="anchor"></a><a class="srclink" href="../src/memory_structs/lib.rs.html#430" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns an inclusive <code>PageRange</code> representing the <a href="../memory_structs/struct.Page.html" title="Page"><code>Page</code></a>s that overlap across this <code>PageRange</code> and the given other <code>PageRange</code>.</p>
<p>If there is no overlap between the two ranges, <code>None</code> is returned.</p>
</div></details></div><h2 id="deref-methods-RangeInclusive%3CPage%3E" class="small-section-header">Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="struct" href="../memory_structs/struct.Page.html" title="struct memory_structs::Page">Page</a>&gt;&gt;<a href="#deref-methods-RangeInclusive%3CPage%3E" class="anchor"></a></h2><div class="impl-items"><details class="rustdoc-toggle" open><summary><h4 id="method.start" class="method"><code>pub const fn <a href="#method.start" class="fnname">start</a>(&amp;self) -&gt; &amp;Idx</code><span class="since" title="Stable since Rust version 1.27.0, const since 1.32.0">1.27.0 (const: 1.32.0)</span><a href="#method.start" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/ops/range.rs.html#399" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the lower bound of the range (inclusive).</p>
<p>When using an inclusive range for iteration, the values of <code>start()</code> and
<a href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html#method.end"><code>end()</code></a> are unspecified after the iteration ended. To determine
whether the inclusive range is empty, use the <a href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html#method.is_empty"><code>is_empty()</code></a> method
instead of comparing <code>start() &gt; end()</code>.</p>
<p>Note: the value returned by this method is unspecified after the range
has been iterated to exhaustion.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>((<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">start</span>(), <span class="kw-2">&amp;</span><span class="number">3</span>);</pre></div>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.end" class="method"><code>pub const fn <a href="#method.end" class="fnname">end</a>(&amp;self) -&gt; &amp;Idx</code><span class="since" title="Stable since Rust version 1.27.0, const since 1.32.0">1.27.0 (const: 1.32.0)</span><a href="#method.end" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/ops/range.rs.html#424" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns the upper bound of the range (inclusive).</p>
<p>When using an inclusive range for iteration, the values of <a href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html#method.start"><code>start()</code></a>
and <code>end()</code> are unspecified after the iteration ended. To determine
whether the inclusive range is empty, use the <a href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html#method.is_empty"><code>is_empty()</code></a> method
instead of comparing <code>start() &gt; end()</code>.</p>
<p>Note: the value returned by this method is unspecified after the range
has been iterated to exhaustion.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>((<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">end</span>(), <span class="kw-2">&amp;</span><span class="number">5</span>);</pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle" open><summary><h4 id="method.contains" class="method"><code>pub fn <a href="#method.contains" class="fnname">contains</a>&lt;U&gt;(&amp;self, item: &amp;U) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Idx: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Idx&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><span class="since" title="Stable since Rust version 1.35.0">1.35.0</span><a href="#method.contains" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/ops/range.rs.html#503-506" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns <code>true</code> if <code>item</code> is contained in the range.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));
<span class="macro">assert!</span>( (<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));
<span class="macro">assert!</span>( (<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">4</span>));
<span class="macro">assert!</span>( (<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">6</span>));

<span class="macro">assert!</span>( (<span class="number">3</span>..<span class="op">=</span><span class="number">3</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3</span>..<span class="op">=</span><span class="number">2</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));

<span class="macro">assert!</span>( (<span class="number">0.0</span>..<span class="op">=</span><span class="number">1.0</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">1.0</span>));
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">0.0</span>..<span class="op">=</span><span class="number">1.0</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">f32::NAN</span>));
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">0.0</span>..<span class="op">=</span><span class="ident">f32::NAN</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">0.0</span>));
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="ident">f32::NAN</span>..<span class="op">=</span><span class="number">1.0</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">1.0</span>));</pre></div>
<p>This method always returns <code>false</code> after iteration has finished:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">r</span> <span class="op">=</span> <span class="number">3</span>..<span class="op">=</span><span class="number">5</span>;
<span class="macro">assert!</span>(<span class="ident">r</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">3</span>) <span class="op">&amp;&amp;</span> <span class="ident">r</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));
<span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="ident">r</span>.<span class="ident">by_ref</span>() {}
<span class="comment">// Precise field values are unspecified here</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">r</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">3</span>) <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">r</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));</pre></div>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.is_empty" class="method"><code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; bool</code><span class="since" title="Stable since Rust version 1.47.0">1.47.0</span><a href="#method.is_empty" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/ops/range.rs.html#539" title="goto source code">[src]</a></h4></summary><div class="docblock"><p>Returns <code>true</code> if the range contains no items.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3</span>..<span class="op">=</span><span class="number">5</span>).<span class="ident">is_empty</span>());
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3</span>..<span class="op">=</span><span class="number">3</span>).<span class="ident">is_empty</span>());
<span class="macro">assert!</span>( (<span class="number">3</span>..<span class="op">=</span><span class="number">2</span>).<span class="ident">is_empty</span>());</pre></div>
<p>The range is empty if either side is incomparable:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert!</span>(<span class="op">!</span>(<span class="number">3.0</span>..<span class="op">=</span><span class="number">5.0</span>).<span class="ident">is_empty</span>());
<span class="macro">assert!</span>( (<span class="number">3.0</span>..<span class="op">=</span><span class="ident">f32::NAN</span>).<span class="ident">is_empty</span>());
<span class="macro">assert!</span>( (<span class="ident">f32::NAN</span>..<span class="op">=</span><span class="number">5.0</span>).<span class="ident">is_empty</span>());</pre></div>
<p>This method returns <code>true</code> after iteration has finished:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">r</span> <span class="op">=</span> <span class="number">3</span>..<span class="op">=</span><span class="number">5</span>;
<span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="ident">r</span>.<span class="ident">by_ref</span>() {}
<span class="comment">// Precise field values are unspecified here</span>
<span class="macro">assert!</span>(<span class="ident">r</span>.<span class="ident">is_empty</span>());</pre></div>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Deref" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-Deref" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#80-85" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="associatedtype.Target" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="type">Target</a> = <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a></code><a href="#associatedtype.Target" class="anchor"></a></h4></summary><div class='docblock'><p>The resulting type after dereferencing.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.deref" class="method trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a></code><a href="#method.deref" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#82-84" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Dereferences the value.</p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-DerefMut" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-DerefMut" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#86-90" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.deref_mut" class="method trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../memory/paging/mapper/struct.MappedPages.html" title="struct memory::paging::mapper::MappedPages">MappedPages</a></code><a href="#method.deref_mut" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#87-89" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Mutably dereferences the value.</p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Drop" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-Drop" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#91-115" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.drop" class="method trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</code><a href="#method.drop" class="anchor"></a><a class="srclink" href="../src/nic_buffers/lib.rs.html#92-114" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Executes the destructor for this type. <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></details></div></details></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-Send" class="anchor"></a></h3><h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-Sync" class="anchor"></a></h3><h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ReceiveBuffer.html" title="struct nic_buffers::ReceiveBuffer">ReceiveBuffer</a></code><a href="#impl-Unpin" class="anchor"></a></h3></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.type_id" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a href="#method.type_id" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.borrow" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;T</code><a href="#method.borrow" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.borrow_mut" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</code><a href="#method.borrow_mut" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.from" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a href="#method.from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="method.into" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a href="#method.into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="associatedtype.Error" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code><a href="#associatedtype.Error" class="anchor"></a></h4></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.try_from" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a></h3></summary><div class="impl-items"><details class="undocumented"><summary></summary><details class="rustdoc-toggle" open><summary><h4 id="associatedtype.Error-1" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code><a href="#associatedtype.Error-1" class="anchor"></a></h4></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle" open><summary><h4 id="method.try_into" class="method trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a></h4></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></details><h3 id="impl-Erased" class="impl"><code class="in-band">impl&lt;T&gt; Erased for T</code><a href="#impl-Erased" class="anchor"></a></h3></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="nic_buffers" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>