# How C compilation works on Theseus

Support for building C programs atop Theseus is experimental and liable to change at any moment.

Currently, we use a custom form of partial linking that splits the linking operations across both build time and runtime. 
The procedure can be broken down into the following steps. 

First, we build the main Theseus OS kernel with all of its Rust crate object files, as normal. 
As part of this, we generate a directory of all the dependencies that another Rust project would need to build against 
These are currently emitted as a set of `.rlib` files (and others) into the `build/deps/` directory. 

TODO: move this to rust_builds_out_of_tree.md.
Second, we use a `theseus_cargo`, a custom wrapper around the `cargo` tool that issues a custom modified build instruction on an out-of-tree Rust crate that instructs it to be built against the
This ensures that the crate built out-of-tree (into a separate target directory) as the rest of Theseus can still be dynamically linked to the proper versions of pre-built Theseus crates, with the right symbol hashes generated by the compiler. 
If we didn't use this, then the out-of-tree crate would be built to expect completely different symbols than 
This is one part of our process to get around the lack of a stable ABI in Rust.



Third, TODO describe our half-partial half-fully-static linking approach split across build time and runtime, where we record relocations that the linker made on our behalf, and then replay them at runtime when Theseus loads the C executable's ELF file, such that we rewrite each relocation to point to (refer to / depend on)  the existing (already-initialized) instances of symbols already loaded into Theseus's kernel, both the data sections and function sections.